<!DOCTYPE html>
<html>
<head>
  <title>Intel x86-64 Assembly Reference Guide</title>
  <meta charset="UTF-8">
  <meta name="keywords" content="x86-64, x64, x86_64, amd64">
<style>

body {
  font: normal 11pt Verdana, Arial, sans-serif;
  color: #181818;
}

a {
  text-decoration: none;
}

code {
  font: normal 11pt "Courier New", mono;
}

div.center {
  text-align: center;
}

div#header {
  position: fixed;
  height: 80px;
  width: 100%;
  top: 0;
  right: 0;
  bottom: auto;
  left: 0;
  overflow: hidden;
  background-color: #726F76;
  color: #FBFBFD;
}

div#toc {
  position: fixed;
  width: 20%;
  height: auto;
  top: 80px;
  right: auto;
  bottom: 0;
  left: 0;
  overflow-y: auto;
  padding-left: 8px;
  background-color: #DDDAE7;
}

div#content {
  position: fixed;
  width: auto;
  height: auto;
  top: 80px;
  right: 0;
  bottom: 0;
  left: 20%;
  overflow-y: auto;
  padding-left: 16px;
  background-color: #FBFBFD;
}

dl {
  margin-left: 2em;
}

dt {
  font-weight: bold;
}

dl.instruction dt {
  font-weight: normal;
  padding-bottom: 1em;
  cursor: pointer;
}

dl.instruction ul {
  margin-left: -2.75em;
  list-style-type: none;
}

dd {
  padding-bottom: 1em;
}

h2 {
  color: #354875;
}

ol#tocOutline {
  color: #04383A;
}

ol#tocOutline a {
  color: #04383A;
}

ol#tocOutline a:hover {
  color: #AF8B44;
}

ul.description {
  list-style-type: circle;
  padding-bottom: 1em;
}

ul.tocSubtopic {
  list-style-type: none;
  margin-left: -2.75em;
  font-size: 11pt;
}

li.tocTopic {
  font-size: 13pt;
}

li.padTop {
  padding-top: 11pt;
}

table {
  border-spacing: 0px;
  border-collapse: collapse;
}

table.center {
  margin-left:auto;
  margin-right:auto;
}

caption, th, td {
  padding: 0.375em;
  line-height: 1.25em;
}

caption {
  font-size: 14pt;
  font-weight: bold;
  color: #354875;
}

th, td {
  border: 1px solid #181818;
}

th {
  font-size: 12pt;
  background: #BEBBC6;
}

th.center {
  text-align: center;
  padding: 0em 1em;
}

td.center {
  text-align: center;
}

td.hex {
  font: 12pt "Courier New", Courier, monospace;
}

td.red {
  color: #60090B;
}

table.stripe tr:nth-child(odd) td {
  background: #E4E4E7;
}

table#x64Registers td.x64 {
  text-align: right;
  font-weight: bold;
  width: 4em;
  border: none;
}

table#x64Registers td.x86_32 {
  text-align: right;
  font-weight: bold;
  width: 32em;
  background: #FCF0B4;
}

table#x64Registers td.x86_16 {
  text-align: right;
  font-weight: bold;
  width: 16em;
  background: #D6C679;
}

table#x64Registers td.x86_8 {
  text-align: center;
  font-weight: bold;
  width: 8em;
  background: #AE9C45;
}

table#abiRegisters {
  width: 20em;
}

table#abiRegisters td {
  text-align: center;
}

table#flagsRegister {
  width: 45em;
}

table#x86jumps tr td:first-child {
  font-weight: bold;
}

table#sse2Register td.sse2 {
  text-align: right;
  font-weight: bold;
  width: 4em;
  border: none;
}

table#sse2Register td.sse2_64 {
  font-weight: bold;
  width: 20em;
  background: #FCF0B4;
  padding-left: 12em;
}

table#sse2Register td.sse2_32 {
  font-weight: bold;
  width: 13em;
  background: #D6C679;
  padding-left: 3em;
}

table#sse2Register td.sse2_16 {
  text-align: center;
  font-weight: bold;
  width: 8em;
  background: #AE9C45;
}

table#sse2Register td.sse2_8 {
  text-align: center;
  font-weight: bold;
  width: 4em;
  color: #FBFBFD;
  background: #8C7A25;
}

</style>
<script>
function toggleDisplay(id) {
  var x = document.getElementById(id);

  if (x.style.display === "none") {
    x.style.display = "block";
  } else {
    x.style.display = "none";
  }
}
</script>
</head>
<body>

<div id="header" class="center">
  <h1>Intel x86-64 Assembly Reference Guide</h1>
</div>

<div id="body">
  <div id="toc">
    <h2>Intel x86-64 Assembly</h2>
    <ol id="tocOutline">
      <li class="tocTopic"><a href="#registers">Registers</a></li>
      <li class="tocTopic padTop">
        <a href="#systemVABI">System V AMD64 ABI</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#intArgRegs">Integer/Pointer Argument Registers</a>
          </li>
          <li><a href="#floatArgRegs">Floating Point Argument Registers</a></li>
          <li><a href="#scratchRegs">Scratch Registers</a></li>
          <li><a href="#calleePreserveRegs">Callee Preserved Registers</a></li>
          <li><a href="#returningValues">Returning Values from Fuctions</a></li>
        </ul>
      </li>
      <li class="tocTopic padTop">
        <a href="#x86JumpInstructions">x86 Jump Instructions</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#x86ProcessorFlags">x86 Processor Flags</a>
          </li>
          <li><a href="#flagsRegister">x86 FLAGS Register</a></li>
          <li><a href="#x86JumpReference">x86 JUMP Instruction Reference</a></li>
          <li><a href="#x86JumpTypes">x86 JUMP Instruction Types</a></li>
        </ul>
      </li>
      <li class="tocTopic padTop">
        <a href="#sse2Instructions">SSE2 Instructions</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#sseRegisters">SSE Registers</a>
          </li>
          <li><a href="#sse2DataMovement">SSE2 Data Movement</a></li>
          <li><a href="#sse2Shuffling">SSE2 Data Shuffling</a></li>
          <li><a href="#sse2Logic">SSE2 Logic Instructions</a></li>
          <li><a href="#sse2Compare">SSE2 Compare Instructions</a></li>
        </ul>
      </li>
    </ol>
  </div>
  <div id="content">
    <h2 id="registers">Registers</h2>
    <p>
    There are sixteen 64-bit general purpose registers broken down into the following
    segments:
    </p>

    <table id="x64Registers" class="center">
    <caption>x86-64 General Purpose Registers</caption>
    <thead>
    <tr>
      <th style="background: #FBFBFD; border: none;">&nbsp;</th>
      <th class="center">Bytes 1-4</th>
      <th class="center">Bytes 5-6</th>
      <th class="center">Byte 7</th>
      <th class="center">Byte 8</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td class="x64">rax</td>
      <td class="x86_32">eax</td>
      <td class="x86_16">ax</td>
      <td class="x86_8">ah</td>
      <td class="x86_8">al</td>
    </tr>
    <tr>
      <td class="x64">rbx</td>
      <td class="x86_32">ebx</td>
      <td class="x86_16">bx</td>
      <td class="x86_8">bh</td>
      <td class="x86_8">bl</td>
    </tr>
    <tr>
      <td class="x64">rcx</td>
      <td class="x86_32">ecx</td>
      <td class="x86_16">cx</td>
      <td class="x86_8">ch</td>
      <td class="x86_8">cl</td>
    </tr>
    <tr>
      <td class="x64">rdx</td>
      <td class="x86_32">edx</td>
      <td class="x86_16">dx</td>
      <td class="x86_8">dh</td>
      <td class="x86_8">dl</td>
    </tr>
    <tr>
      <td class="x64">rsi</td>
      <td class="x86_32">esi</td>
      <td class="x86_16">si</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">sil</td>
    </tr>
    <tr>
      <td class="x64">rdi</td>
      <td class="x86_32">edi</td>
      <td class="x86_16">di</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">dil</td>
    </tr>
    <tr>
      <td class="x64">rsp</td>
      <td class="x86_32">esp</td>
      <td class="x86_16">sp</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">spl</td>
    </tr>
    <tr>
      <td class="x64">rbp</td>
      <td class="x86_32">ebp</td>
      <td class="x86_16">bp</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">bpl</td>
    </tr>
    <tr>
      <td class="x64">r8</td>
      <td class="x86_32">r8d</td>
      <td class="x86_16">r8w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r8b</td>
    </tr>
    <tr>
      <td class="x64">r9</td>
      <td class="x86_32">r9d</td>
      <td class="x86_16">r9w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r9b</td>
    </tr>
    <tr>
      <td class="x64">r10</td>
      <td class="x86_32">r10d</td>
      <td class="x86_16">r10w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r10b</td>
    </tr>
    <tr>
      <td class="x64">r11</td>
      <td class="x86_32">r11d</td>
      <td class="x86_16">r11w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r11b</td>
    </tr>
    <tr>
      <td class="x64">r12</td>
      <td class="x86_32">r12d</td>
      <td class="x86_16">r12w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r12b</td>
    </tr>
    <tr>
      <td class="x64">r13</td>
      <td class="x86_32">r13d</td>
      <td class="x86_16">r13w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r13b</td>
    </tr>
    <tr>
      <td class="x64">r14</td>
      <td class="x86_32">r14d</td>
      <td class="x86_16">r14w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r14b</td>
    </tr>
    <tr>
      <td class="x64">r15</td>
      <td class="x86_32">r15d</td>
      <td class="x86_16">r15w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r15b</td>
    </tr>
    </tbody>
    </table>

    <h2 id="systemVABI">System V AMD64 ABI</h2>
    <p>
    The System V AMD64 ABI calling convention is followed on Solaris, Linux, FreeBSD,
    macOS, and is the de facto standard among Unix and Unix-like operating systems.
    </p>

    <h3>Calling Convention Characteristics</h3>
    <ul>
      <li>The first six integer or pointer arguments are passed in registers <code>RDI</code>,
          <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>,
          <code>R9</code></li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="intArgRegs">Integer/Pointer Argument Registers</caption>
    <tr>
      <td>rdi</td>
    </tr>
    <tr>
      <td>rsi</td>
    </tr>
    <tr>
      <td>rdx</td>
    </tr>
    <tr>
      <td>rcx</td>
    </tr>
    <tr>
      <td>r8</td>
    </tr>
    <tr>
      <td>r9</td>
    </tr>
    </table>

    <ul>
      <li>The SSE registers <code>XMM0</code>, <code>XMM1</code>, <code>XMM2</code>,
          <code>XMM3</code>, <code>XMM4</code>, <code>XMM5</code>, <code>XMM6</code>
          and <code>XMM7</code> are used for floating point arguments</li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="floatArgRegs">Floating Point Argument Registers</caption>
    <tr>
      <td>xmm0</td>
    </tr>
    <tr>
      <td>xmm1</td>
    </tr>
    <tr>
      <td>xmm2</td>
    </tr>
    <tr>
      <td>xmm3</td>
    </tr>
    <tr>
      <td>xmm4</td>
    </tr>
    <tr>
      <td>xmm5</td>
    </tr>
    <tr>
      <td>xmm6</td>
    </tr>
    <tr>
      <td>xmm7</td>
    </tr>
    </table>

    <h4>Calling Functions</h4>
    <ul>
      <li>All other arguments are passed on the stack as they appear on the function
          definition in Right-to-Left order</li>
      <li>Functions are called using the <code>call</code> instruction which
          pushes the address of the next instruction onto the stack before
          calling the specified function</li>
      <ul>
        <li>The stack must be 16-byte aligned just before making the call instruction</li>
      </ul>
      <li>Scratch registers that can be used by the function include <code>RAX</code>,
          <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>,
          <code>R8</code>, <code>R9</code>, <code>R10</code>, and <code>R11</code></li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="scratchRegs">Scratch Registers</caption>
    <tr>
      <td>rax</td>
    </tr>
    <tr>
      <td>rdi</td>
    </tr>
    <tr>
      <td>rsi</td>
    </tr>
    <tr>
      <td>rdx</td>
    </tr>
    <tr>
      <td>rcx</td>
    </tr>
    <tr>
      <td>r8</td>
    </tr>
    <tr>
      <td>r9</td>
    </tr>
    <tr>
      <td>r10</td>
    </tr>
    <tr>
      <td>r11</td>
    </tr>
    </table>

    <ul>
      <li>Functions must preserve the registers <code>RBX</code>, <code>RSP</code>,
          <code>RBP</code>, <code>R12</code>, <code>R13</code>, <code>R14</code>,
          and <code>R15</code> if they will be used by the function</li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="calleePreserveRegs">Callee Preserved Registers</caption>
    <tr>
      <td>rbx</td>
    </tr>
    <tr>
      <td>rsp</td>
    </tr>
    <tr>
      <td>rbp</td>
    </tr>
    <tr>
      <td>r12</td>
    </tr>
    <tr>
      <td>r13</td>
    </tr>
    <tr>
      <td>r14</td>
    </tr>
    <tr>
      <td>r15</td>
    </tr>
    </table>

    <h3 id="returningValues">Returning Values from Fuctions</h3>
    <ul>
      <li>Functions return to the caller using the <code>ret</code> instruction
          which pops the return address from the stack and jumps to it</li>
      <li>32-bit integer return values are stored in <code>EAX</code></li>
      <li>64-bit integer return values are stored in <code>RAX</code></li>
      <li>128-bit integer return values are stored in <code>RDX</code>:<code>RAX</code></li>
      <li>32-bit float and 64-bit double return values are stored in <code>XMM0</code></li>
      <li>128-bit double return values are stored in <code>XMM0:XMM1</code></li>
    </ul>

    <h2 id="x86JumpInstructions">x86 JUMP Instructions</h2>
    <p>
    JUMP instructions transfer program control to another part of the code
    segment. Essentially it is a GOTO statement (for those who know what BASIC
    is). The JUMPs destination is usually specified by a label indicating the
    address of the next instruction to execute. Other possible JUMP operands
    include immediate values, a general-purpose register, or a memory location.
    <br><br>
    All special-purpose JUMP instructions are based upon the state of the
    <b>x86 Processor Flags</b>.
    </p>

    <h3 id="x86ProcessorFlags">x86 Processor Flags</h3>
    <p>
    The <b>FLAGS</b> register is the status register that contains the current
    state of the processor. The register is 16 bits wide.
    </p>
    <ul>
      <li>The <b>EFLAGS</b> register is the 32-bit version of the status
          register and is backwards compatible with the <b>FLAGS</b> register</li>
      <li><b>RFLAGS</b> is the name of the 64-bit status register</li>
    </ul>

    <p>
    The most commonly used flags and their meanings are as follows:
    <dl>
     <dt>Carry Flag (CF)</dt>
     <dd>Set when an arithmetic carry or borrow occurs from the most significant bit
         during an arithmetic or bit-wise operation; cleared otherwise</dd>
     <dt>Parity Flag (PF)</dt>
     <dd>Reflects the parity of just the least significant byte of the instruction
         result. PF is set to one if the number of set bits is even</dd>
     <dt>Zero Flag (ZF)</dt>
     <dd>Set if the arithmetic or bit-wise operation results in zero; cleared otherwise</dd>
     <dt>Sign Flag (SF)</dt>
     <dd>Set if the instruction sets the most significant bit to one; cleared otherwise</dd>
     <dt>Overflow Flag (SF)</dt>
     <dd>Set when an arithmetic overflow of a signed number has occurred during the
         execution of an operation; meaningless for unsigned numbers</dd>
    </dl>
    </p>

    <table id="flagsRegister" class="center stripe">
    <caption>x86 FLAGS Register</caption>
    <thead>
    <tr>
    <th>Bit #</th>
    <th>Mask</th>
    <th>Abbreviation</th>
    <th>Description</th>
    <th>Category</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td class="center">0</td>
    <td>0x0001</td>
    <td class="center">CF</td>
    <td>Carry Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">1</td>
    <td>0x0002</td>
    <td class="center">&nbsp;</td>
    <td>Reserved (always 1 in EFLAGS)</td>
    <td class="center">&nbsp;</td>
    </tr>
    <tr>
    <td class="center">2</td>
    <td>0x0004</td>
    <td class="center">PF</td>
    <td>Parity Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">3</td>
    <td>0x0008</td>
    <td class="center">&nbsp;</td>
    <td>Reserved</td>
    <td class="center">&nbsp;</td>
    </tr>
    <tr>
    <td class="center">4</td>
    <td>0x0010</td>
    <td class="center">AF</td>
    <td>Adjust Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">5</td>
    <td>0x0020</td>
    <td class="center">&nbsp;</td>
    <td>Reserved</td>
    <td class="center">&nbsp;</td>
    </tr>
    <tr>
    <td class="center">6</td>
    <td>0x0040</td>
    <td class="center">ZF</td>
    <td>Zero Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">7</td>
    <td>0x0080</td>
    <td class="center">SF</td>
    <td>Sign Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">8</td>
    <td>0x0100</td>
    <td class="center">TF</td>
    <td>Trap Flag</td>
    <td class="center">Control</td>
    </tr>
    <tr>
    <td class="center">9</td>
    <td>0x0200</td>
    <td class="center">IF</td>
    <td>Interrupt Enable Flag</td>
    <td class="center">Control</td>
    </tr>
    <tr>
    <td class="center">10</td>
    <td>0x0400</td>
    <td class="center">DF</td>
    <td>Direction Flag</td>
    <td class="center">Control</td>
    </tr>
    <tr>
    <td class="center">11</td>
    <td>0x0800</td>
    <td class="center">OF</td>
    <td>Overflow Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">12-13</td>
    <td>0x3000</td>
    <td class="center">IOPL</td>
    <td>I/O Privilege Level</td>
    <td class="center">System</td>
    </tr>
    <tr>
    <td class="center">14</td>
    <td>0x4000</td>
    <td class="center">NT</td>
    <td>Nested Task Flag</td>
    <td class="center">System</td>
    </tr>
    <tr>
    <td class="center">15</td>
    <td>0x8000</td>
    <td class="center">&nbsp;</td>
    <td>Reserved</td>
    <td class="center">&nbsp;</td>
    </tr>
    </tbody>
    </table>

    <h3 id="x86JumpReference">x86 JUMP Instruction Reference</h3>
    <p>
    The following is an Intel x86 JUMP Reference table made by
    <a href="http://unixwiz.net/techtips/x86-jumps.html">Steve Friedl</a>
    in which he says, "many of the instructions are synonyms for each other, and in
    practice the entire instruction collection is not needed".
    <br><br>
    Steve grouped the JUMP instructions by functionality, with all instruction
    synonyms in the same row.
    </p>

    <table id="x86jumps" class="center stripe">
      <caption>x86 JUMP Instruction Reference</caption>
    <thead>
      <tr>
        <th rowspan="2">Instruction</th>
        <th rowspan="2">Description</th>
        <th rowspan="2">Signedness</th>
        <th rowspan="2">Flags</th>
        <th colspan="2">Opcodes</th>
      </tr>
      <tr>
        <th>Short Jump</th>
        <th>Near Jump</th>
      </tr>
    </thead>
    <tbody>
    <tr>
      <td>JO</td>
      <td>Jump if overflow</td>
      <td>&nbsp;</td>
      <td>OF = 1</td>
      <td class="hex">70</td>
      <td class="hex">0F 80</td>
    </tr>
    <tr>
      <td>JNO</td>
      <td>Jump if not overflow</td>
      <td>&nbsp;</td>
      <td>OF = 0</td>
      <td class="hex">71</td>
      <td class="hex">0F 81</td>
    </tr>
    <tr>
      <td>JS</td>
      <td>Jump if sign</td>
      <td>&nbsp;</td>
      <td>SF = 1</td>
      <td class="hex">78</td>
      <td class="hex">0F 88</td>
    </tr>
    <tr>
      <td>JNS</td>
      <td>Jump if not sign</td>
      <td>&nbsp;</td>
      <td>SF = 0</td>
      <td class="hex">79</td>
      <td class="hex">0F 89</td>
    </tr>
    <tr>
      <td>JE<br>JZ</td>
      <td>
        Jump if equal<br>
        Jump if zero
      </td>
      <td>&nbsp;</td>
      <td>ZF = 1</td>
      <td class="hex">74</td>
      <td class="hex">0F 84</td>
    </tr>
    <tr>
      <td>JNE<br>JNZ</td>
      <td>
        Jump if not equal<br>
        Jump if not zero
      </td>
      <td>&nbsp;</td>
      <td>ZF = 0</td>
      <td class="hex">75</td>
      <td class="hex">0F 85</td>
    </tr>
    <tr>
      <td>JB<br>JNAE<br>JC</td>
      <td>
        Jump if below<br>
        Jump if not above or equal<br>
        Jump if carry
      </td>
      <td>unsigned</td>
      <td>CF = 1</td>
      <td class="hex">72</td>
      <td class="hex">0F 82</td>
    </tr>
    <tr>
      <td>JNB<br>JAE<br>JNC</td>
      <td>
        Jump if not below<br>
        Jump if above or equal<br>
        Jump if not carry
      </td>
      <td>unsigned</td>
      <td>CF = 0</td>
      <td class="hex">73</td>
      <td class="hex">0F 83</td>
    </tr>
    <tr>
      <td>JBE<br>JNA</td>
      <td>
        Jump if below or equal<br>
        Jump if not above
      </td>
      <td>unsigned</td>
      <td>CF = 1 or ZF = 1</td>
      <td class="hex">76</td>
      <td class="hex">0F 86</td>
    </tr>
    <tr>
      <td>JA<br>JNBE</td>
      <td>
        Jump if above<br>
        Jump if not below or equal
      </td>
      <td>unsigned</td>
      <td>CF = 0 and ZF = 0</td>
      <td class="hex">77</td>
      <td class="hex">0F 87</td>
    </tr>
    <tr>
      <td>JL<br>JNGE</td>
      <td>
        Jump if less<br>
        Jump if not greater or equal
      </td>
      <td>signed</td>
      <td>SF &lt;&gt; OF</td>
      <td class="hex">7C</td>
      <td class="hex">0F 8C</td>
    </tr>
    <tr>
      <td>JGE<br>JNL</td>
      <td>
        Jump if greater or equal<br>
        Jump if not less
      </td>
      <td>signed</td>
      <td>SF = OF</td>
      <td class="hex">7D</td>
      <td class="hex">0F 8D</td>
    </tr>
    <tr>
      <td>JLE<br>JNG</td>
      <td>
        Jump if less or equal<br>
        Jump if not greater
      </td>
      <td>signed</td>
      <td>ZF = 1 or SF &lt;&gt; OF</td>
      <td class="hex">7E</td>
      <td class="hex">0F 8E</td>
    </tr>
    <tr>
      <td>JG<br>JNLE</td>
      <td>
        Jump if greater<br>
        Jump if not less or equal
      </td>
      <td>signed</td>
      <td>ZF = 0 and SF = OF</td>
      <td class="hex">7F</td>
      <td class="hex">0F 8F</td>
    </tr>
    <tr>
      <td>JP<br>JPE</td>
      <td>
        Jump if parity<br>
        Jump if parity even
      </td>
      <td>&nbsp;</td>
      <td>PF = 1</td>
      <td class="hex">7A</td>
      <td class="hex">0F 8A</td>
    </tr>
    <tr>
      <td>JNP<br>JPO</td>
      <td>
        Jump if not parity<br>
        Jump if parity odd
      </td>
      <td>&nbsp;</td>
      <td>PF = 0</td>
      <td class="hex">7B</td>
      <td class="hex">0F 8B</td>
    </tr>
    <tr>
      <td>JCXZ<br>JECXZ</td>
      <td>
        Jump if CX register is 0<br>
        Jump if ECX register is 0
      </td>
      <td>&nbsp;</td>
      <td>CX = 0<br>ECX = 0</td>
      <td class="hex">E3</td>
      <td class="hex">&nbsp;</td>
    </tr>
    </tbody>
    </table>

    <h3 id="x86JumpTypes">x86 JUMP Instruction Types</h3>
    <p>
    There are four types of jump instructions, each of which are generally
    encoded as follows:
    <ul>
      <li>Jump instruction</li>
      <li>The number of bytes to jump (+/-)</li>
    </ul>
    <dl>
      <dt>Short Jump</dt>
      <ul class="description">
        <li>A signed byte (+127/-128) jump relative to the current instruction pointer (IP)</li>
        <li>Encoded as two bytes: one byte for the jump instruction and another byte for the number of bytes to jump</li>
      </ul>
      <dt>Near Jump</dt>
      <ul class="description">
        <li>A signed integer (+2,147,483,647/-2,147,483,648) jump relative to the current instruction pointer (IP) and within the current code segment as defined by the 16-bit CS register</li>
        <li>Encoded as six bytes: two bytes for the jump instruction and another four bytes for the number of bytes to jump</li>
      </ul>
      <dt>Far Jump</dt>
      <ul class="description">
        <li>A signed integer (+2,147,483,647/-2,147,483,648) absolute jump that specifies both the code segment (CS) and offset (IP)</li>
        <li>The jump must be to an instruction at the same privilege level</li>
        <li>Encoded as ??? bytes: ??? bytes for the jump instruction and another four bytes for the number of bytes to jump</li>
      </ul>
      <dt>Task Switch</dt>
      <ul class="description">
        <li>A jump to an instruction located in a different task</li>
        <li>Can only be executed in protected mode</li>
      </ul>
    </dl>
    </p>

    <h2 id="sse2Instructions">SSE2 Instructions</h2>
    <p>
    SSE2 instructions give a lot of flexibility and power to the SIMD execution
    model by allowing calclations with:
    </p>
    <ul>
      <li>64-bit double-precision floating-point values</li>
      <li>64-bit integer values</li>
      <li>32-bit single-precision floating-point values</li>
      <li>32-bit integer values</li>
      <li>16-bit integer values</li>
      <li>8-bit integer values</li>
    </ul>

    <h3 id="sseRegisters">SSE Registers</h3>
    <p>
    In the x86-64 architecture, there are sixteen 128-bit SSE registers
    <code>XMM0</code>, <code>XMM1</code>, <code>XMM2</code>, <code>XMM3</code>,
    <code>XMM4</code>, <code>XMM5</code>, <code>XMM6</code>, <code>XMM7</code>,
    <code>XMM8</code>, <code>XMM9</code>, <code>XMM10</code>, <code>XMM11</code>,
    <code>XMM12</code>, <code>XMM13</code>, <code>XMM14</code>, and <code>XMM15</code>
    </p>

    <table id="abiRegisters" class="center stripe">
    <caption id="floatArgRegs">SSE Registers</caption>
    <tr>
      <td>xmm0</td>
    </tr>
    <tr>
      <td>xmm1</td>
    </tr>
    <tr>
      <td>xmm2</td>
    </tr>
    <tr>
      <td>xmm3</td>
    </tr>
    <tr>
      <td>xmm4</td>
    </tr>
    <tr>
      <td>xmm5</td>
    </tr>
    <tr>
      <td>xmm6</td>
    </tr>
    <tr>
      <td>xmm7</td>
    </tr>
    <tr>
      <td>xmm8</td>
    </tr>
    <tr>
      <td>xmm9</td>
    </tr>
    <tr>
      <td>xmm10</td>
    </tr>
    <tr>
      <td>xmm11</td>
    </tr>
    <tr>
      <td>xmm12</td>
    </tr>
    <tr>
      <td>xmm13</td>
    </tr>
    <tr>
      <td>xmm14</td>
    </tr>
    <tr>
      <td>xmm15</td>
    </tr>
    </table>

    <p>
    The structure of each SSE2 register is as follows:
    </p>

    <table id="sse2Register" class="center">
    <caption>SSE2 Register Layout</caption>
    <thead>
    <tr>
      <th style="background: #FBFBFD; border: none;">&nbsp;</th>
      <th class="center" colspan="8">Bytes 1-8</th>
      <th class="center" colspan="8">Bytes 9-16</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td class="sse2">2</td>
      <td class="sse2_64" colspan="8">64-bit floating-point<br>64-bit integer</td>
      <td class="sse2_64" colspan="8">64-bit floating-point<br>64-bit integer</td>
    </tr>
    <tr>
      <td class="sse2">4</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
    </tr>
    <tr>
      <td class="sse2">8</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
    </tr>
    <tr>
      <td class="sse2">16</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
    </tr>
    </tbody>
    </table>

    <h3 id="sse2DataMovement">SSE2 Data Movement</h3>
    <p>
    The first thing to learn about SSE2 is how to move data into, out of, and
    between the XMM registers:
    <dl class="instruction">
     <dt onclick="toggleDisplay('movd')"><b>movd</b> &boxh; move doubleword</dt>
     <dd id="movd" style="display: none;">
       <ul>
         <li>Moves the value in a 32-bit register or memory location into the
             bottom 32 bits of an XMM register; top 96 bits are cleared</li>
         <li>Moves the value in the bottom 32 bits of an XMM register into a
             32-bit register or memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movd &lt;xmm&gt;, &lt;reg32&#47;mem32&gt;</code><br>
       <code>movd &lt;reg32&#47;mem32&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movd xmm0, eax</code><br>
       <code>movd [rdi], xmm0</code>
     </dd>
     <dt onclick="toggleDisplay('movq')"><b>movq</b> &boxh; move quadword</dt>
     <dd id="movq" style="display: none;">
       <ul>
         <li>Moves the value in a 64-bit register or memory location into the
             bottom 64 bits of an XMM register; top 64 bits are cleared</li>
         <li>Moves the value in the bottom 64 bits of an XMM register into a
             64-bit register or memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movq &lt;xmm&gt;, &lt;reg64&#47;mem64&gt;</code><br>
       <code>movq &lt;reg64&#47;mem64&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movq xmm0, rax</code><br>
       <code>movq [rdi], xmm0</code>
     </dd>
     <dt onclick="toggleDisplay('movdqa')"><b>movdqa</b> &boxh; move aligned 128-bit integer</dt>
     <dd id="movdqa" style="display: none;">
       <ul>
         <li>Moves a 128-bit integer value from an XMM register or 16-byte aligned
             memory location into an XMM register</li>
         <li>Moves the 128-bit integer value from an XMM register into another XMM
             register or a 16-byte aligned memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movdqa &lt;xmm&gt;, &lt;xmm&#47;mem128&gt;</code><br>
       <code>movdqa &lt;xmm&#47;mem128&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movdqa xmm0, [rdi]</code><br>
       <code>movdqa xmm1, xmm0</code><br>
       <code>movdqa [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movdqu')"><b>movdqu</b> &boxh; move unaligned 128-bit integer</dt>
     <dd id="movdqu" style="display: none;">
       <ul>
         <li>Moves a 128-bit integer value from an unaligned memory location into
             an XMM register</li>
         <li>Moves the 128-bit integer value from an XMM register into an unaligned
             memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movdqu &lt;xmm&gt;, &lt;mem128&gt;</code><br>
       <code>movdqu &lt;mem128&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movdqu xmm0, [rdi]</code><br>
       <code>movdqu [rdi], xmm0</code>
     </dd>
     <dt onclick="toggleDisplay('movapd')"><b>movapd</b> &boxh; move aligned packed double-precision floating-point values</dt>
     <dd id="movapd" style="display: none;">
       <ul>
         <li>Moves two 64-bit double-precision floating-point values from an
             XMM register or 16-byte aligned memory location into an XMM register</li>
         <li>Moves two 64-bit double-precision floating-point values from an
             XMM register into another XMM register or a 16-byte aligned memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movapd &lt;xmm&gt;, &lt;xmm&#47;mem128&gt;</code><br>
       <code>movapd &lt;xmm&#47;mem128&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movapd xmm0, [rdi]</code><br>
       <code>movapd xmm1, xmm0</code><br>
       <code>movapd [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movupd')"><b>movupd</b> &boxh; move unaligned packed double-precision floating-point values</dt>
     <dd id="movupd" style="display: none;">
       <ul>
         <li>Moves two 64-bit double-precision floating-point values from an
             unaligned memory location into an XMM register</li>
         <li>Moves two 64-bit double-precision floating-point values from an
             XMM register into an unaligned memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movupd &lt;xmm&gt;, &lt;mem128&gt;</code><br>
       <code>movupd &lt;mem128&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movupd xmm0, [rdi]</code><br>
       <code>movupd [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movaps')"><b>movaps</b> &boxh; move aligned packed single-precision floating-point values</dt>
     <dd id="movaps" style="display: none;">
       <ul>
         <li>Moves four 32-bit single-precision floating-point values from an
             XMM register or 16-byte aligned memory location into an XMM register</li>
         <li>Moves four 32-bit single-precision floating-point values from an
             XMM register into another XMM register or a 16-byte aligned memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movaps &lt;xmm&gt;, &lt;xmm&#47;mem128&gt;</code><br>
       <code>movaps &lt;xmm&#47;mem128&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movaps xmm0, [rdi]</code><br>
       <code>movaps xmm1, xmm0</code><br>
       <code>movaps [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movups')"><b>movups</b> &boxh; move unaligned packed single-precision floating-point values</dt>
     <dd id="movups" style="display: none;">
       <ul>
         <li>Moves four 32-bit single-precision floating-point values from an
             unaligned memory location into an XMM register</li>
         <li>Moves four 32-bit single-precision floating-point values from an
             XMM register into an unaligned memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movups &lt;xmm&gt;, &lt;mem128&gt;</code><br>
       <code>movups &lt;mem128&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movups xmm0, [rdi]</code><br>
       <code>movups [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movhps')"><b>movhps</b> &boxh; move high packed single-precision floating-point values</dt>
     <dd id="movhps" style="display: none;">
       <ul>
         <li>Moves two 32-bit single-precision floating-point values from a
             64-bit memory location into the top 64 bits of the XMM register</li>
         <li>Moves the top 64 bits of an XMM register into the 64-bit memory
             location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movhps &lt;xmm&gt;, &lt;mem64&gt;</code><br>
       <code>movhps &lt;mem64&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movhps xmm0, [rdi]</code><br>
       <code>movhps [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movlps')"><b>movlps</b> &boxh; move low packed single-precision floating-point values</dt>
     <dd id="movlps" style="display: none;">
       <ul>
         <li>Moves two 32-bit single-precision floating-point values from a
             64-bit memory location into the bottom 64 bits of the XMM register</li>
         <li>Moves the bottom 64 bits of an XMM register into the 64-bit memory
             location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movlps &lt;xmm&gt;, &lt;mem64&gt;</code><br>
       <code>movlps &lt;mem64&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movlps xmm0, [rdi]</code><br>
       <code>movlps [rdi], xmm1</code>
     </dd>
     <dt onclick="toggleDisplay('movhlps')"><b>movhlps</b> &boxh; move packed single-precision floating-point values high to low</dt>
     <dd id="movhlps" style="display: none;">
       <ul>
         <li>Moves two 32-bit single-precision floating-point values from the top
             64 bits of the source XMM register to the bottom 64 bits of the
             destination XMM register</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movhlps &lt;xmm&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movhlps xmm0, xmm1</code><br>
     </dd>
     <dt onclick="toggleDisplay('movlhps')"><b>movlhps</b> &boxh; move packed single-precision floating-point values low to high</dt>
     <dd id="movlhps" style="display: none;">
       <ul>
         <li>Moves two 32-bit single-precision floating-point values from the bottom
             64 bits of the source XMM register to the top 64 bits of the
             destination XMM register</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movlhps &lt;xmm&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movlhps xmm0, xmm1</code><br>
     </dd>
     <dt onclick="toggleDisplay('movss')"><b>movss</b> &boxh; move scalar single-precision floating-point value</dt>
     <dd id="movss" style="display: none;">
       <ul>
         <li>Moves a 32-bit single-precision floating-point value from a memory
             location into an XMM register</li>
         <li>Moves the single lowest 32-bit single-precision floating-point value
             from a source XMM register to a destination XMM register</li>
         <li>Moves scalar 32-bit single-precision floating-point value
             from a source XMM register into a memory location</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movss &lt;xmm&gt;, &lt;xmm&#47;mem32&gt;</code><br>
       <code>movss &lt;xmm&#47;mem32&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movss xmm0, [rdi]</code><br>
       <code>movss xmm0, xmm1</code><br>
       <code>movss [rdi], xmm1</code><br>
     </dd>
     <dt onclick="toggleDisplay('movmskps')"><b>movmskps</b> &boxh; extract packed single-precision floating-point sign mask</dt>
     <dd id="movmskps" style="display: none;">
       <ul>
         <li>Extracts the sign bits from the four packed 32-bit single-precision
             floating-point values, formats them into a 4-bit mask, and stores
             it in the 4 low-order bits of the general-purpose register</li>
       </ul>
       <br>
       <em>Syntax</em><br>
       <code>movmskps &lt;reg64&gt;, &lt;xmm&gt;</code><br>
       <br>
       <em>Examples</em><br>
       <code>movmskps rax, xmm1</code><br>
     </dd>
    </dl>
    </p>

    <h3 id="sse2Shuffling">SSE2 Data Shuffling</h3>
    <p>
    A key concept about performing SIMD operations with SSE2 is the "multiple
    data" part. Data shuffling allows 16-bit words / 32-bit doublewords / 64-bit
    quadwords to be repackaged in a different way in an XMM register.
    <dl class="instruction">
      <dt onclick="toggleDisplay('pshufd')"><b>pshufd</b> &boxh; shuffle packed doublewords</dt>
      <dd id="pshufd" style="display: none;">
        <ul>
          <li>Copies 32-bit doublewords from the source and inserts them into
              the destination XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
          <li>The immediate operand is an 8-bit mask that selects which 32-bit
              doublewords from the source are placed into the destination</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pshufd &lt;xmm&gt;, &lt;xmm&gt;, 01101100b</code><br>
        <code>pshufd &lt;xmm&gt;, &lt;mem128&gt;, 10110110b</code><br>
        <br>
        <em>Examples</em><br>
        <code>pshufd xmm0, xmm0, 0b</code> &boxh; broadcast the lowest 32-bit doubleword in <code>XMM0</code><br>
        <code>pshufd xmm0, [rdi], 10110110b</code><br>
      </dd>
      <dt onclick="toggleDisplay('pshuflw')"><b>pshuflw</b> &boxh; shuffle packed low words</dt>
      <dd id="pshuflw" style="display: none;">
        <ul>
          <li>Copies 16-bit words from the bottom 64 bits of the source and
              inserts them into the bottom four 16-bit words of the destination
              XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
          <li>The immediate operand is an 8-bit mask that selects which 16-bit
              words from the source are placed into the destination</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pshuflw &lt;xmm&gt;, &lt;xmm&gt;, 01101100b</code><br>
        <code>pshuflw &lt;xmm&gt;, &lt;mem128&gt;, 10110110b</code><br>
        <br>
        <em>Examples</em><br>
        <code>pshuflw xmm0, xmm0, 0b</code> &boxh; broadcast the lowest 16-bit word in <code>XMM0</code><br>
        <code>pshuflw xmm0, [rdi], 10110110b</code><br>
      </dd>
    </dl>
    </p>

    <h3 id="sse2Logic">SSE2 Logic Instructions</h3>
    <p>
    The SSE2 logic instructions allow the capability to perform the usual bitwise
    logic on XMM registers. Some logic instructions operate on the entire 128-bit
    register as a whole, while other logic instructions perform operations on
    packed values within the XMM register.
    <dl class="instruction">
      <dt onclick="toggleDisplay('pand')"><b>pand</b> &boxh; logical AND</dt>
      <dd id="pand" style="display: none;">
        <ul>
          <li>Performs a 128-bit bitwise logical AND operation between the source
              and destination XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pand &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pand &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pand xmm0, xmm1</code><br>
        <code>pand xmm0, [rdi]</code><br>
      </dd>
      <dt onclick="toggleDisplay('pxor')"><b>pxor</b> &boxh; logical exclusive OR</dt>
      <dd id="pxor" style="display: none;">
        <ul>
          <li>Performs a 128-bit bitwise logical exclusive OR operation between
              the source and destination XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pxor &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pxor &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pxor xmm0, xmm1</code><br>
        <code>pxor xmm0, [rdi]</code><br>
      </dd>
      <dt onclick="toggleDisplay('pandn')"><b>pandn</b> &boxh; logical AND NOT</dt>
      <dd id="pandn" style="display: none;">
        <ul>
          <li>Performs a 128-bit bitwise logical NOT operation on the destination
              XMM register and then performs a bitwise logical AND with the source</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pandn &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pandn &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pandn xmm0, xmm1</code><br>
        <code>pandn xmm0, [rdi]</code><br>
      </dd>
    </dl>

    <h3 id="sse2Compare">SSE2 Compare Instructions</h3>
    <p>
    SSE2 compare functionality is quite limited considering there are only a
    couple compare operations for integers.
    <dl class="instruction">
      <dt onclick="toggleDisplay('pcmpeqb')"><b>pcmpeqb</b> &boxh; compare packed bytes for equal</dt>
      <dd id="pcmpeqb" style="display: none;">
        <ul>
          <li>Performs a SIMD compare for equality of the packed bytes between the
              destination XMM register and the source</li>
          <li>If a pair of bytes are equal, the corresponding byte in the
              destination XMM register is set to <code>0xff</code>; otherwise
              it is set to <code>0x00</code></li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pcmpeqb &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pcmpeqb &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pcmpeqb xmm0, xmm1</code><br>
        <code>pcmpeqb xmm0, [rdi]</code><br>
      </dd>
    </dl>
    </p>

    <br/>
    <div class="center">Copyright &copy; 2019 <a href="https://www.devopsbroker.org/">DevOpsBroker.org</a></div>
    <br/>
  </div>
</div>

</body>
</html>
