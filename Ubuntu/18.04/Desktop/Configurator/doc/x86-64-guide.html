<!DOCTYPE html>
<html>
<head>
  <title>Intel x86-64 Assembly Reference Guide</title>
  <meta charset="UTF-8">
  <meta name="keywords" content="x86-64, x64, x86_64, amd64">
<style>

body {
  font: normal 11pt Verdana, Arial, sans-serif;
  color: #181818;
}

a {
  text-decoration: none;
}

code {
  font: normal 11pt "Courier New", mono;
}

div.center {
  text-align: center;
}

div#header {
  position: fixed;
  height: 80px;
  width: 100%;
  top: 0;
  right: 0;
  bottom: auto;
  left: 0;
  overflow: hidden;
  background-color: #726F76;
  color: #FBFBFD;
}

div#toc {
  position: fixed;
  min-width: 387px;
  height: auto;
  top: 80px;
  right: auto;
  bottom: 0;
  left: 0;
  overflow-y: auto !important;
  padding-left: 8px;
  background-color: #DDDAE7;
}

div#content {
  position: fixed;
  min-width: 776px;
  height: auto;
  top: 80px;
  right: 0;
  bottom: 0;
  left: 395px;
  overflow-y: auto !important;
  padding-left: 16px;
  background-color: #FBFBFD;
}

dl {
  margin-left: 2em;
}

dt {
  font-weight: bold;
}

dl.instruction dt {
  font-weight: normal;
  padding-bottom: 1em;
  cursor: pointer;
}

dl.instruction ul {
  margin-left: -2.75em;
  list-style-type: none;
}

dd {
  padding-bottom: 1em;
}

h2 {
  color: #354875;
}

ol#tocOutline {
  color: #04383A;
}

ol#tocOutline a {
  color: #04383A;
}

ol#tocOutline a:hover {
  color: #AF8B44;
}

ul.description {
  list-style-type: circle;
  padding-bottom: 1em;
}

ul.tocSubtopic {
  list-style-type: none;
  margin-left: -2.75em;
  font-size: 11pt;
}

li.tocTopic {
  font-size: 13pt;
}

li.padTop {
  padding-top: 11pt;
}

table {
  border-spacing: 0px;
  border-collapse: collapse;
}

table.center {
  margin-left:auto;
  margin-right:auto;
}

caption, th, td {
  padding: 0.375em;
  line-height: 1.25em;
}

caption {
  font-size: 14pt;
  font-weight: bold;
  color: #354875;
}

th, td {
  border: 1px solid #181818;
}

th {
  font-size: 12pt;
  background: #BEBBC6;
}

th.center {
  text-align: center;
  padding: 0em 1em;
}

td.center {
  text-align: center;
}

td.hex {
  font: 12pt "Courier New", Courier, monospace;
}

td.red {
  color: #60090B;
}

table.stripe tr:nth-child(odd) td {
  background: #E4E4E7;
}

table#x64Registers td.x64 {
  text-align: right;
  font-weight: bold;
  width: 4em;
  border: none;
}

table#x64Registers td.x86_32 {
  text-align: right;
  font-weight: bold;
  width: 32em;
  background: #FCF0B4;
}

table#x64Registers td.x86_16 {
  text-align: right;
  font-weight: bold;
  width: 16em;
  background: #D6C679;
}

table#x64Registers td.x86_8 {
  text-align: center;
  font-weight: bold;
  width: 8em;
  background: #AE9C45;
}

table#abiRegisters {
  width: 20em;
}

table#abiRegisters td {
  text-align: center;
}

table#flagsRegister {
  width: 45em;
}

table#x86jumps tr td:first-child {
  font-weight: bold;
}

table#sse2Register td.sse2 {
  text-align: right;
  font-weight: bold;
  width: 4em;
  border: none;
}

table#sse2Register td.sse2_64 {
  font-weight: bold;
  width: 20em;
  background: #FCF0B4;
  padding-left: 12em;
}

table#sse2Register td.sse2_32 {
  font-weight: bold;
  width: 13em;
  background: #D6C679;
  padding-left: 3em;
}

table#sse2Register td.sse2_16 {
  text-align: center;
  font-weight: bold;
  width: 8em;
  background: #AE9C45;
}

table#sse2Register td.sse2_8 {
  text-align: center;
  font-weight: bold;
  width: 4em;
  color: #FBFBFD;
  background: #8C7A25;
}

</style>
<script>
function toggleDisplay(id) {
  var x = document.getElementById(id);

  if (x.style.display === "none") {
    x.style.display = "block";
  } else {
    x.style.display = "none";
  }
}
</script>
</head>
<body>

<div id="header" class="center">
  <h1>Intel x86-64 Assembly Reference Guide</h1>
</div>

<div id="body">
  <div id="toc">
    <h2>Intel x86-64 Assembly</h2>
    <ol id="tocOutline">
      <li class="tocTopic"><a href="#registers">Registers</a></li>
      <li class="tocTopic padTop">
        <a href="#systemVABI">System V AMD64 ABI</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#intArgRegs">Integer/Pointer Argument Registers</a>
          </li>
          <li><a href="#floatArgRegs">Floating Point Argument Registers</a></li>
          <li><a href="#scratchRegs">Scratch Registers</a></li>
          <li><a href="#calleePreserveRegs">Callee Preserved Registers</a></li>
          <li><a href="#returningValues">Returning Values from Fuctions</a></li>
        </ul>
      </li>
      <li class="tocTopic padTop">
        <a href="#x86JumpInstructions">x86 Jump Instructions</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#x86ProcessorFlags">x86 Processor Flags</a>
          </li>
          <li><a href="#flagsRegister">x86 FLAGS Register</a></li>
          <li><a href="#x86JumpReference">x86 JUMP Instruction Reference</a></li>
          <li><a href="#x86JumpTypes">x86 JUMP Instruction Types</a></li>
        </ul>
      </li>
      <li class="tocTopic padTop">
        <a href="#x86_64Instructions">x86_64 Instructions</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#arithmeticOps">Arithmetic Operations</a>
          </li>
          <li><a href="#sse2DataMovement">SSE2 Data Movement</a></li>
          <li><a href="#sse2Shuffling">SSE2 Data Shuffling</a></li>
          <li><a href="#sse2Arithmetic">SSE2 Arithmetic Instructions</a></li>
          <li><a href="#sse2Logic">SSE2 Logic Instructions</a></li>
          <li><a href="#sse2Compare">SSE2 Compare Instructions</a></li>
        </ul>
      </li>
      <li class="tocTopic padTop">
        <a href="#sse2Instructions">SSE2 Instructions</a>
        <ul class="tocSubtopic">
          <li class="padTop">
            <a href="#sseRegisters">SSE Registers</a>
          </li>
          <li><a href="#sse2DataMovement">SSE2 Data Movement</a></li>
          <li><a href="#sse2Shuffling">SSE2 Data Shuffling</a></li>
          <li><a href="#sse2Arithmetic">SSE2 Arithmetic Instructions</a></li>
          <li><a href="#sse2Logic">SSE2 Logic Instructions</a></li>
          <li><a href="#sse2Compare">SSE2 Compare Instructions</a></li>
        </ul>
      </li>
    </ol>
  </div>
  <div id="content">
    <h2 id="registers">Registers</h2>
    <p>
    There are sixteen 64-bit general purpose registers broken down into the following
    segments:
    </p>

    <table id="x64Registers" class="center">
    <caption>x86-64 General Purpose Registers</caption>
    <thead>
    <tr>
      <th style="background: #FBFBFD; border: none;">&nbsp;</th>
      <th class="center">Bytes 1-4</th>
      <th class="center">Bytes 5-6</th>
      <th class="center">Byte 7</th>
      <th class="center">Byte 8</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td class="x64">rax</td>
      <td class="x86_32">eax</td>
      <td class="x86_16">ax</td>
      <td class="x86_8">ah</td>
      <td class="x86_8">al</td>
    </tr>
    <tr>
      <td class="x64">rbx</td>
      <td class="x86_32">ebx</td>
      <td class="x86_16">bx</td>
      <td class="x86_8">bh</td>
      <td class="x86_8">bl</td>
    </tr>
    <tr>
      <td class="x64">rcx</td>
      <td class="x86_32">ecx</td>
      <td class="x86_16">cx</td>
      <td class="x86_8">ch</td>
      <td class="x86_8">cl</td>
    </tr>
    <tr>
      <td class="x64">rdx</td>
      <td class="x86_32">edx</td>
      <td class="x86_16">dx</td>
      <td class="x86_8">dh</td>
      <td class="x86_8">dl</td>
    </tr>
    <tr>
      <td class="x64">rsi</td>
      <td class="x86_32">esi</td>
      <td class="x86_16">si</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">sil</td>
    </tr>
    <tr>
      <td class="x64">rdi</td>
      <td class="x86_32">edi</td>
      <td class="x86_16">di</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">dil</td>
    </tr>
    <tr>
      <td class="x64">rsp</td>
      <td class="x86_32">esp</td>
      <td class="x86_16">sp</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">spl</td>
    </tr>
    <tr>
      <td class="x64">rbp</td>
      <td class="x86_32">ebp</td>
      <td class="x86_16">bp</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">bpl</td>
    </tr>
    <tr>
      <td class="x64">r8</td>
      <td class="x86_32">r8d</td>
      <td class="x86_16">r8w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r8b</td>
    </tr>
    <tr>
      <td class="x64">r9</td>
      <td class="x86_32">r9d</td>
      <td class="x86_16">r9w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r9b</td>
    </tr>
    <tr>
      <td class="x64">r10</td>
      <td class="x86_32">r10d</td>
      <td class="x86_16">r10w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r10b</td>
    </tr>
    <tr>
      <td class="x64">r11</td>
      <td class="x86_32">r11d</td>
      <td class="x86_16">r11w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r11b</td>
    </tr>
    <tr>
      <td class="x64">r12</td>
      <td class="x86_32">r12d</td>
      <td class="x86_16">r12w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r12b</td>
    </tr>
    <tr>
      <td class="x64">r13</td>
      <td class="x86_32">r13d</td>
      <td class="x86_16">r13w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r13b</td>
    </tr>
    <tr>
      <td class="x64">r14</td>
      <td class="x86_32">r14d</td>
      <td class="x86_16">r14w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r14b</td>
    </tr>
    <tr>
      <td class="x64">r15</td>
      <td class="x86_32">r15d</td>
      <td class="x86_16">r15w</td>
      <td class="x86_8 red">X</td>
      <td class="x86_8">r15b</td>
    </tr>
    </tbody>
    </table>

    <h2 id="systemVABI">System V AMD64 ABI</h2>
    <p>
    The System V AMD64 ABI calling convention is followed on Solaris, Linux, FreeBSD,
    macOS, and is the de facto standard among Unix and Unix-like operating systems.
    </p>

    <h3>Calling Convention Characteristics</h3>
    <ul>
      <li>The first six integer or pointer arguments are passed in registers <code>RDI</code>,
          <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>,
          <code>R9</code></li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="intArgRegs">Integer/Pointer Argument Registers</caption>
    <tr>
      <td>rdi</td>
    </tr>
    <tr>
      <td>rsi</td>
    </tr>
    <tr>
      <td>rdx</td>
    </tr>
    <tr>
      <td>rcx</td>
    </tr>
    <tr>
      <td>r8</td>
    </tr>
    <tr>
      <td>r9</td>
    </tr>
    </table>

    <ul>
      <li>The SSE registers <code>XMM0</code>, <code>XMM1</code>, <code>XMM2</code>,
          <code>XMM3</code>, <code>XMM4</code>, <code>XMM5</code>, <code>XMM6</code>
          and <code>XMM7</code> are used for floating point arguments</li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="floatArgRegs">Floating Point Argument Registers</caption>
    <tr>
      <td>xmm0</td>
    </tr>
    <tr>
      <td>xmm1</td>
    </tr>
    <tr>
      <td>xmm2</td>
    </tr>
    <tr>
      <td>xmm3</td>
    </tr>
    <tr>
      <td>xmm4</td>
    </tr>
    <tr>
      <td>xmm5</td>
    </tr>
    <tr>
      <td>xmm6</td>
    </tr>
    <tr>
      <td>xmm7</td>
    </tr>
    </table>

    <h4>Calling Functions</h4>
    <ul>
      <li>All other arguments are passed on the stack as they appear on the function
          definition in Right-to-Left order</li>
      <li>Functions are called using the <code>call</code> instruction which
          pushes the address of the next instruction onto the stack before
          calling the specified function</li>
      <ul>
        <li>The stack must be 16-byte aligned just before making the call instruction</li>
      </ul>
      <li>If the function being called is a variadic function, then the number of
          floating point arguments must be provided in the <code>AL</code> register</li>
      <li><b>TODO:</b> The ABI needs to be extended so that the number of non-floating
          point variadic arguments is passed in the <code>AH</code> register</li>
      <li>Scratch registers that can be used by the function include <code>RAX</code>,
          <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>,
          <code>R8</code>, <code>R9</code>, <code>R10</code>, and <code>R11</code></li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="scratchRegs">Scratch Registers</caption>
    <tr>
      <td>rax</td>
    </tr>
    <tr>
      <td>rdi</td>
    </tr>
    <tr>
      <td>rsi</td>
    </tr>
    <tr>
      <td>rdx</td>
    </tr>
    <tr>
      <td>rcx</td>
    </tr>
    <tr>
      <td>r8</td>
    </tr>
    <tr>
      <td>r9</td>
    </tr>
    <tr>
      <td>r10</td>
    </tr>
    <tr>
      <td>r11</td>
    </tr>
    </table>

    <ul>
      <li>Functions must preserve the registers <code>RBX</code>, <code>RSP</code>,
          <code>RBP</code>, <code>R12</code>, <code>R13</code>, <code>R14</code>,
          and <code>R15</code> if they will be used by the function</li>
    </ul>

    <table id="abiRegisters" class="center stripe">
    <caption id="calleePreserveRegs">Callee Preserved Registers</caption>
    <tr>
      <td>rbx</td>
    </tr>
    <tr>
      <td>rsp</td>
    </tr>
    <tr>
      <td>rbp</td>
    </tr>
    <tr>
      <td>r12</td>
    </tr>
    <tr>
      <td>r13</td>
    </tr>
    <tr>
      <td>r14</td>
    </tr>
    <tr>
      <td>r15</td>
    </tr>
    </table>

    <h3 id="returningValues">Returning Values from Fuctions</h3>
    <ul>
      <li>Functions return to the caller using the <code>ret</code> instruction
          which pops the return address from the stack and jumps to it</li>
      <li>32-bit integer return values are stored in <code>EAX</code></li>
      <li>64-bit integer return values are stored in <code>RAX</code></li>
      <li>128-bit integer return values are stored in <code>RDX</code>:<code>RAX</code></li>
      <li>32-bit float and 64-bit double return values are stored in <code>XMM0</code></li>
      <li>128-bit double return values are stored in <code>XMM0:XMM1</code></li>
    </ul>

    <h2 id="x86JumpInstructions">x86 JUMP Instructions</h2>
    <p>
    JUMP instructions transfer program control to another part of the code
    segment. Essentially it is a GOTO statement (for those who know what BASIC
    is). The JUMPs destination is usually specified by a label indicating the
    address of the next instruction to execute. Other possible JUMP operands
    include immediate values, a general-purpose register, or a memory location.
    <br><br>
    All special-purpose JUMP instructions are based upon the state of the
    <b>x86 Processor Flags</b>.
    </p>

    <h3 id="x86ProcessorFlags">x86 Processor Flags</h3>
    <p>
    The <b>FLAGS</b> register is the status register that contains the current
    state of the processor. The register is 16 bits wide.
    </p>
    <ul>
      <li>The <b>EFLAGS</b> register is the 32-bit version of the status
          register and is backwards compatible with the <b>FLAGS</b> register</li>
      <li><b>RFLAGS</b> is the name of the 64-bit status register</li>
    </ul>

    <p>
    The most commonly used flags and their meanings are as follows:
    </p>
    <dl>
     <dt>Carry Flag (CF)</dt>
     <dd>Set when an arithmetic carry or borrow occurs from the most significant bit
         during an arithmetic or bit-wise operation; cleared otherwise</dd>
     <dt>Parity Flag (PF)</dt>
     <dd>Reflects the parity of just the least significant byte of the instruction
         result. PF is set to one if the number of set bits is even</dd>
     <dt>Zero Flag (ZF)</dt>
     <dd>Set if the arithmetic or bit-wise operation results in zero; cleared otherwise</dd>
     <dt>Sign Flag (SF)</dt>
     <dd>Set if the instruction sets the most significant bit to one; cleared otherwise</dd>
     <dt>Overflow Flag (SF)</dt>
     <dd>Set when an arithmetic overflow of a signed number has occurred during the
         execution of an operation; meaningless for unsigned numbers</dd>
    </dl>

    <table id="flagsRegister" class="center stripe">
    <caption>x86 FLAGS Register</caption>
    <thead>
    <tr>
    <th>Bit #</th>
    <th>Mask</th>
    <th>Abbreviation</th>
    <th>Description</th>
    <th>Category</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td class="center">0</td>
    <td>0x0001</td>
    <td class="center">CF</td>
    <td>Carry Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">1</td>
    <td>0x0002</td>
    <td class="center">&nbsp;</td>
    <td>Reserved (always 1 in EFLAGS)</td>
    <td class="center">&nbsp;</td>
    </tr>
    <tr>
    <td class="center">2</td>
    <td>0x0004</td>
    <td class="center">PF</td>
    <td>Parity Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">3</td>
    <td>0x0008</td>
    <td class="center">&nbsp;</td>
    <td>Reserved</td>
    <td class="center">&nbsp;</td>
    </tr>
    <tr>
    <td class="center">4</td>
    <td>0x0010</td>
    <td class="center">AF</td>
    <td>Adjust Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">5</td>
    <td>0x0020</td>
    <td class="center">&nbsp;</td>
    <td>Reserved</td>
    <td class="center">&nbsp;</td>
    </tr>
    <tr>
    <td class="center">6</td>
    <td>0x0040</td>
    <td class="center">ZF</td>
    <td>Zero Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">7</td>
    <td>0x0080</td>
    <td class="center">SF</td>
    <td>Sign Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">8</td>
    <td>0x0100</td>
    <td class="center">TF</td>
    <td>Trap Flag</td>
    <td class="center">Control</td>
    </tr>
    <tr>
    <td class="center">9</td>
    <td>0x0200</td>
    <td class="center">IF</td>
    <td>Interrupt Enable Flag</td>
    <td class="center">Control</td>
    </tr>
    <tr>
    <td class="center">10</td>
    <td>0x0400</td>
    <td class="center">DF</td>
    <td>Direction Flag</td>
    <td class="center">Control</td>
    </tr>
    <tr>
    <td class="center">11</td>
    <td>0x0800</td>
    <td class="center">OF</td>
    <td>Overflow Flag</td>
    <td class="center">Status</td>
    </tr>
    <tr>
    <td class="center">12-13</td>
    <td>0x3000</td>
    <td class="center">IOPL</td>
    <td>I/O Privilege Level</td>
    <td class="center">System</td>
    </tr>
    <tr>
    <td class="center">14</td>
    <td>0x4000</td>
    <td class="center">NT</td>
    <td>Nested Task Flag</td>
    <td class="center">System</td>
    </tr>
    <tr>
    <td class="center">15</td>
    <td>0x8000</td>
    <td class="center">&nbsp;</td>
    <td>Reserved</td>
    <td class="center">&nbsp;</td>
    </tr>
    </tbody>
    </table>

    <h3 id="x86JumpReference">x86 JUMP Instruction Reference</h3>
    <p>
    The following is an Intel x86 JUMP Reference table made by
    <a href="http://unixwiz.net/techtips/x86-jumps.html">Steve Friedl</a>
    in which he says, "many of the instructions are synonyms for each other, and in
    practice the entire instruction collection is not needed".
    <br><br>
    Steve grouped the JUMP instructions by functionality, with all instruction
    synonyms in the same row.
    </p>

    <table id="x86jumps" class="center stripe">
      <caption>x86 JUMP Instruction Reference</caption>
    <thead>
      <tr>
        <th rowspan="2">Instruction</th>
        <th rowspan="2">Description</th>
        <th rowspan="2">Signedness</th>
        <th rowspan="2">Flags</th>
        <th colspan="2">Opcodes</th>
      </tr>
      <tr>
        <th>Short Jump</th>
        <th>Near Jump</th>
      </tr>
    </thead>
    <tbody>
    <tr>
      <td>JO</td>
      <td>Jump if overflow</td>
      <td>&nbsp;</td>
      <td>OF = 1</td>
      <td class="hex">70</td>
      <td class="hex">0F 80</td>
    </tr>
    <tr>
      <td>JNO</td>
      <td>Jump if not overflow</td>
      <td>&nbsp;</td>
      <td>OF = 0</td>
      <td class="hex">71</td>
      <td class="hex">0F 81</td>
    </tr>
    <tr>
      <td>JS</td>
      <td>Jump if sign</td>
      <td>&nbsp;</td>
      <td>SF = 1</td>
      <td class="hex">78</td>
      <td class="hex">0F 88</td>
    </tr>
    <tr>
      <td>JNS</td>
      <td>Jump if not sign</td>
      <td>&nbsp;</td>
      <td>SF = 0</td>
      <td class="hex">79</td>
      <td class="hex">0F 89</td>
    </tr>
    <tr>
      <td>JE<br>JZ</td>
      <td>
        Jump if equal<br>
        Jump if zero
      </td>
      <td>&nbsp;</td>
      <td>ZF = 1</td>
      <td class="hex">74</td>
      <td class="hex">0F 84</td>
    </tr>
    <tr>
      <td>JNE<br>JNZ</td>
      <td>
        Jump if not equal<br>
        Jump if not zero
      </td>
      <td>&nbsp;</td>
      <td>ZF = 0</td>
      <td class="hex">75</td>
      <td class="hex">0F 85</td>
    </tr>
    <tr>
      <td>JB<br>JNAE<br>JC</td>
      <td>
        Jump if below<br>
        Jump if not above or equal<br>
        Jump if carry
      </td>
      <td>unsigned</td>
      <td>CF = 1</td>
      <td class="hex">72</td>
      <td class="hex">0F 82</td>
    </tr>
    <tr>
      <td>JNB<br>JAE<br>JNC</td>
      <td>
        Jump if not below<br>
        Jump if above or equal<br>
        Jump if not carry
      </td>
      <td>unsigned</td>
      <td>CF = 0</td>
      <td class="hex">73</td>
      <td class="hex">0F 83</td>
    </tr>
    <tr>
      <td>JBE<br>JNA</td>
      <td>
        Jump if below or equal<br>
        Jump if not above
      </td>
      <td>unsigned</td>
      <td>CF = 1 or ZF = 1</td>
      <td class="hex">76</td>
      <td class="hex">0F 86</td>
    </tr>
    <tr>
      <td>JA<br>JNBE</td>
      <td>
        Jump if above<br>
        Jump if not below or equal
      </td>
      <td>unsigned</td>
      <td>CF = 0 and ZF = 0</td>
      <td class="hex">77</td>
      <td class="hex">0F 87</td>
    </tr>
    <tr>
      <td>JL<br>JNGE</td>
      <td>
        Jump if less<br>
        Jump if not greater or equal
      </td>
      <td>signed</td>
      <td>SF &lt;&gt; OF</td>
      <td class="hex">7C</td>
      <td class="hex">0F 8C</td>
    </tr>
    <tr>
      <td>JGE<br>JNL</td>
      <td>
        Jump if greater or equal<br>
        Jump if not less
      </td>
      <td>signed</td>
      <td>SF = OF</td>
      <td class="hex">7D</td>
      <td class="hex">0F 8D</td>
    </tr>
    <tr>
      <td>JLE<br>JNG</td>
      <td>
        Jump if less or equal<br>
        Jump if not greater
      </td>
      <td>signed</td>
      <td>ZF = 1 or SF &lt;&gt; OF</td>
      <td class="hex">7E</td>
      <td class="hex">0F 8E</td>
    </tr>
    <tr>
      <td>JG<br>JNLE</td>
      <td>
        Jump if greater<br>
        Jump if not less or equal
      </td>
      <td>signed</td>
      <td>ZF = 0 and SF = OF</td>
      <td class="hex">7F</td>
      <td class="hex">0F 8F</td>
    </tr>
    <tr>
      <td>JP<br>JPE</td>
      <td>
        Jump if parity<br>
        Jump if parity even
      </td>
      <td>&nbsp;</td>
      <td>PF = 1</td>
      <td class="hex">7A</td>
      <td class="hex">0F 8A</td>
    </tr>
    <tr>
      <td>JNP<br>JPO</td>
      <td>
        Jump if not parity<br>
        Jump if parity odd
      </td>
      <td>&nbsp;</td>
      <td>PF = 0</td>
      <td class="hex">7B</td>
      <td class="hex">0F 8B</td>
    </tr>
    <tr>
      <td>JCXZ<br>JECXZ<br>JRCXZ</td>
      <td>
        Jump if CX register is 0<br>
        Jump if ECX register is 0<br>
        Jump if RCX register is 0
      </td>
      <td>&nbsp;</td>
      <td>CX = 0<br>ECX = 0<br>RCX = 0</td>
      <td class="hex">E3</td>
      <td class="hex">&nbsp;</td>
    </tr>
    </tbody>
    </table>

    <h3 id="x86JumpTypes">x86 JUMP Instruction Types</h3>
    <p>
    There are four types of jump instructions, each of which are generally
    encoded as follows:
    </p>
    <ul>
      <li>Jump instruction</li>
      <li>The number of bytes to jump (+/-)</li>
    </ul>
    <dl>
      <dt>Short Jump</dt>
      <ul class="description">
        <li>A signed byte (+127/-128) jump relative to the current instruction pointer (IP)</li>
        <li>Encoded as two bytes: one byte for the jump instruction and another byte for the number of bytes to jump</li>
      </ul>
      <dt>Near Jump</dt>
      <ul class="description">
        <li>A signed integer (+2,147,483,647/-2,147,483,648) jump relative to the current instruction pointer (IP) and within the current code segment as defined by the 16-bit CS register</li>
        <li>Encoded as six bytes: two bytes for the jump instruction and another four bytes for the number of bytes to jump</li>
      </ul>
      <dt>Far Jump</dt>
      <ul class="description">
        <li>A signed integer (+2,147,483,647/-2,147,483,648) absolute jump that specifies both the code segment (CS) and offset (IP)</li>
        <li>The jump must be to an instruction at the same privilege level</li>
        <li>Encoded as ??? bytes: ??? bytes for the jump instruction and another four bytes for the number of bytes to jump</li>
      </ul>
      <dt>Task Switch</dt>
      <ul class="description">
        <li>A jump to an instruction located in a different task</li>
        <li>Can only be executed in protected mode</li>
      </ul>
    </dl>

    <h2 id="x86_64Instructions">x86_64 Instructions</h2>
    <p>
      There are many, many x86_64 instructions available to a software developer.
      The ubiquitous instructions are <code>mov</code>, <code>cmp</code>,
      <code>test</code>, and the corresponding <code>jmp</code> instructions as
      listed above.
      <br><br>
      These sections intend to cover a small subset of the available instructions
      while giving tips on how to effectively use them in your own assembly
      language code.
    </p>

    <h3 id="arithmeticOps">Arithmetic Operations</h3>
    <dl class="instruction">
      <dt onclick="toggleDisplay('add')"><b>add</b> &boxh; add</dt>
      <dd id="add" style="display: none;">
        <ul>
          <li>Adds the destination and source operands together</li>
          <li>The destination operand can be a register or a memory location</li>
          <li>The source operand can be an immediate, a register, or a memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>add &lt;reg&gt;, &lt;imm&gt;</code><br>
        <code>add &lt;reg&gt;, &lt;mem&gt;</code><br>
        <code>add &lt;reg&gt;, &lt;reg&gt;</code><br>
        <code>add &lt;mem&gt;, &lt;imm&gt;</code><br>
        <code>add &lt;mem&gt;, &lt;reg&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>add eax, edx</code><br>
        <code>add [rdi], eax</code><br>
        <code>add rsi, 0x08</code>
      </dd>
      <dt onclick="toggleDisplay('xadd')"><b>xadd</b> &boxh; exchange and add</dt>
      <dd id="xadd" style="display: none;">
        <ul>
          <li>Exchanges the destination and source operand values</li>
          <li>Places the sum of the values into the destination</li>
          <li>The destination operand can be either a register or memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>xadd &lt;reg&gt;, &lt;reg&gt;</code><br>
        <code>xadd &lt;mem&gt;, &lt;reg&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>xadd eax, edx</code><br>
        <code>xadd [rdi], eax</code><br>
      </dd>
      <dt onclick="toggleDisplay('dec')"><b>dec</b> &boxh; decrement by one</dt>
      <dd id="dec" style="display: none;">
        <ul>
          <li>Subtracts one from the destination operand</li>
          <li>The destination operand can be either a register or memory location</li>
          <li>Can update a loop counter without disturbing the CF flag</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>dec &lt;reg&gt;</code><br>
        <code>dec &lt;mem&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>dec eax</code><br>
        <code>dec [rdi]</code><br>
      </dd>
    </dl>

    <h2 id="sse2Instructions">SSE2 Instructions</h2>
    <p>
    SSE2 instructions give a lot of flexibility and power to the SIMD execution
    model by allowing calclations with:
    </p>
    <ul>
      <li>64-bit double-precision floating-point values</li>
      <li>64-bit integer values</li>
      <li>32-bit single-precision floating-point values</li>
      <li>32-bit integer values</li>
      <li>16-bit integer values</li>
      <li>8-bit integer values</li>
    </ul>

    <h3 id="sseRegisters">SSE Registers</h3>
    <p>
    In the x86-64 architecture, there are sixteen 128-bit SSE registers
    <code>XMM0</code>, <code>XMM1</code>, <code>XMM2</code>, <code>XMM3</code>,
    <code>XMM4</code>, <code>XMM5</code>, <code>XMM6</code>, <code>XMM7</code>,
    <code>XMM8</code>, <code>XMM9</code>, <code>XMM10</code>, <code>XMM11</code>,
    <code>XMM12</code>, <code>XMM13</code>, <code>XMM14</code>, and <code>XMM15</code>
    </p>

    <table id="abiRegisters" class="center stripe">
    <caption id="floatArgRegs">SSE Registers</caption>
    <tr>
      <td>xmm0</td>
    </tr>
    <tr>
      <td>xmm1</td>
    </tr>
    <tr>
      <td>xmm2</td>
    </tr>
    <tr>
      <td>xmm3</td>
    </tr>
    <tr>
      <td>xmm4</td>
    </tr>
    <tr>
      <td>xmm5</td>
    </tr>
    <tr>
      <td>xmm6</td>
    </tr>
    <tr>
      <td>xmm7</td>
    </tr>
    <tr>
      <td>xmm8</td>
    </tr>
    <tr>
      <td>xmm9</td>
    </tr>
    <tr>
      <td>xmm10</td>
    </tr>
    <tr>
      <td>xmm11</td>
    </tr>
    <tr>
      <td>xmm12</td>
    </tr>
    <tr>
      <td>xmm13</td>
    </tr>
    <tr>
      <td>xmm14</td>
    </tr>
    <tr>
      <td>xmm15</td>
    </tr>
    </table>

    <p>
    The structure of each SSE2 register is as follows:
    </p>
    <table id="sse2Register" class="center">
    <caption>SSE2 Register Layout</caption>
    <thead>
    <tr>
      <th style="background: #FBFBFD; border: none;">&nbsp;</th>
      <th class="center" colspan="8">Bytes 1-8</th>
      <th class="center" colspan="8">Bytes 9-16</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td class="sse2">2</td>
      <td class="sse2_64" colspan="8">64-bit floating-point<br>64-bit integer</td>
      <td class="sse2_64" colspan="8">64-bit floating-point<br>64-bit integer</td>
    </tr>
    <tr>
      <td class="sse2">4</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
      <td class="sse2_32" colspan="4">32-bit floating-point<br>32-bit integer</td>
    </tr>
    <tr>
      <td class="sse2">8</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
      <td class="sse2_16" colspan="2">16-bit</td>
    </tr>
    <tr>
      <td class="sse2">16</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
      <td class="sse2_8">8-bit</td>
    </tr>
    </tbody>
    </table>

    <h3 id="sse2DataMovement">SSE2 Data Movement</h3>
    <p>
    The first thing to learn about SSE2 is how to move data into, out of, and
    between the XMM registers:
    </p>
    <dl class="instruction">
      <dt onclick="toggleDisplay('movd')"><b>movd</b> &boxh; move doubleword</dt>
      <dd id="movd" style="display: none;">
        <ul>
          <li>Moves the value in a 32-bit register or memory location into the
              bottom 32 bits of an XMM register; top 96 bits are cleared</li>
          <li>Moves the value in the bottom 32 bits of an XMM register into a
              32-bit register or memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movd &lt;xmm&gt;, &lt;reg32&#47;mem32&gt;</code><br>
        <code>movd &lt;reg32&#47;mem32&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movd xmm0, eax</code><br>
        <code>movd [rdi], xmm0</code>
      </dd>
      <dt onclick="toggleDisplay('movq')"><b>movq</b> &boxh; move quadword</dt>
      <dd id="movq" style="display: none;">
        <ul>
          <li>Moves the value in a 64-bit register or memory location into the
              bottom 64 bits of an XMM register; top 64 bits are cleared</li>
          <li>Moves the value in the bottom 64 bits of an XMM register into a
              64-bit register or memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movq &lt;xmm&gt;, &lt;reg64&#47;mem64&gt;</code><br>
        <code>movq &lt;reg64&#47;mem64&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movq xmm0, rax</code><br>
        <code>movq [rdi], xmm0</code>
      </dd>
      <dt onclick="toggleDisplay('movdqa')"><b>movdqa</b> &boxh; move aligned 128-bit integer</dt>
      <dd id="movdqa" style="display: none;">
        <ul>
          <li>Moves a 128-bit integer value from an XMM register or 16-byte aligned
              memory location into an XMM register</li>
          <li>Moves the 128-bit integer value from an XMM register into another XMM
              register or a 16-byte aligned memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movdqa &lt;xmm&gt;, &lt;xmm&#47;mem128&gt;</code><br>
        <code>movdqa &lt;xmm&#47;mem128&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movdqa xmm0, [rdi]</code><br>
        <code>movdqa xmm1, xmm0</code><br>
        <code>movdqa [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movdqu')"><b>movdqu</b> &boxh; move unaligned 128-bit integer</dt>
      <dd id="movdqu" style="display: none;">
        <ul>
          <li>Moves a 128-bit integer value from an unaligned memory location
              into an XMM register</li>
          <li>Moves the 128-bit integer value from an XMM register into an
              unaligned memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movdqu &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <code>movdqu &lt;mem128&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movdqu xmm0, [rdi]</code><br>
        <code>movdqu [rdi], xmm0</code>
      </dd>
      <dt onclick="toggleDisplay('movapd')"><b>movapd</b> &boxh; move aligned packed double-precision floating-point values</dt>
      <dd id="movapd" style="display: none;">
        <ul>
          <li>Moves two 64-bit double-precision floating-point values from an
              XMM register or 16-byte aligned memory location into an XMM register</li>
          <li>Moves two 64-bit double-precision floating-point values from an
              XMM register into another XMM register or a 16-byte aligned memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movapd &lt;xmm&gt;, &lt;xmm&#47;mem128&gt;</code><br>
        <code>movapd &lt;xmm&#47;mem128&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movapd xmm0, [rdi]</code><br>
        <code>movapd xmm1, xmm0</code><br>
        <code>movapd [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movupd')"><b>movupd</b> &boxh; move unaligned packed double-precision floating-point values</dt>
      <dd id="movupd" style="display: none;">
        <ul>
          <li>Moves two 64-bit double-precision floating-point values from an
              unaligned memory location into an XMM register</li>
          <li>Moves two 64-bit double-precision floating-point values from an
              XMM register into an unaligned memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movupd &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <code>movupd &lt;mem128&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movupd xmm0, [rdi]</code><br>
        <code>movupd [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movaps')"><b>movaps</b> &boxh; move aligned packed single-precision floating-point values</dt>
      <dd id="movaps" style="display: none;">
        <ul>
          <li>Moves four 32-bit single-precision floating-point values from an
              XMM register or 16-byte aligned memory location into an XMM register</li>
          <li>Moves four 32-bit single-precision floating-point values from an
              XMM register into another XMM register or a 16-byte aligned memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movaps &lt;xmm&gt;, &lt;xmm&#47;mem128&gt;</code><br>
        <code>movaps &lt;xmm&#47;mem128&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movaps xmm0, [rdi]</code><br>
        <code>movaps xmm1, xmm0</code><br>
        <code>movaps [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movups')"><b>movups</b> &boxh; move unaligned packed single-precision floating-point values</dt>
      <dd id="movups" style="display: none;">
        <ul>
          <li>Moves four 32-bit single-precision floating-point values from an
              unaligned memory location into an XMM register</li>
          <li>Moves four 32-bit single-precision floating-point values from an
              XMM register into an unaligned memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movups &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <code>movups &lt;mem128&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movups xmm0, [rdi]</code><br>
        <code>movups [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movhpd')"><b>movhpd</b> &boxh; move high packed double-precision floating-point value</dt>
      <dd id="movhpd" style="display: none;">
        <ul>
          <li>Moves a 64-bit double-precision floating-point value from the
              source 64-bit memory location into the top 64 bits of the XMM register</li>
          <li>The bottom 64 bits of the XMM register are preserved</li>
          <li>Cannot be used to move between XMM registers</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movhpd &lt;xmm&gt;, &lt;mem64&gt;</code><br>
        <code>movhpd &lt;mem64&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movhpd xmm0, [rdi]</code><br>
        <code>movhpd [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movlpd')"><b>movlpd</b> &boxh; move low packed double-precision floating-point value</dt>
      <dd id="movlpd" style="display: none;">
        <ul>
          <li>Moves a 64-bit double-precision floating-point value from the
              source 64-bit memory location into the bottom 64 bits of the XMM register</li>
          <li>The top 64 bits of the XMM register are preserved</li>
          <li>Cannot be used to move between XMM registers</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movlpd &lt;xmm&gt;, &lt;mem64&gt;</code><br>
        <code>movlpd &lt;mem64&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movlpd xmm0, [rdi]</code><br>
        <code>movlpd [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movhps')"><b>movhps</b> &boxh; move high packed single-precision floating-point values</dt>
      <dd id="movhps" style="display: none;">
        <ul>
          <li>Moves two 32-bit single-precision floating-point values from a
              64-bit memory location into the top 64 bits of the XMM register</li>
          <li>The bottom 64 bits of the XMM register are preserved</li>
          <li>Cannot be used to move between XMM registers</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movhps &lt;xmm&gt;, &lt;mem64&gt;</code><br>
        <code>movhps &lt;mem64&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movhps xmm0, [rdi]</code><br>
        <code>movhps [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movlps')"><b>movlps</b> &boxh; move low packed single-precision floating-point values</dt>
      <dd id="movlps" style="display: none;">
        <ul>
          <li>Moves two 32-bit single-precision floating-point values from a
              64-bit memory location into the bottom 64 bits of the XMM register</li>
          <li>The top 64 bits of the XMM register are preserved</li>
          <li>Cannot be used to move between XMM registers</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movlps &lt;xmm&gt;, &lt;mem64&gt;</code><br>
        <code>movlps &lt;mem64&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movlps xmm0, [rdi]</code><br>
        <code>movlps [rdi], xmm1</code>
      </dd>
      <dt onclick="toggleDisplay('movhlps')"><b>movhlps</b> &boxh; move packed single-precision floating-point values high to low</dt>
      <dd id="movhlps" style="display: none;">
        <ul>
          <li>Moves two 32-bit single-precision floating-point values from the
              top 64 bits of the source XMM register to the bottom 64 bits of
              the destination XMM register</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movhlps &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movhlps xmm0, xmm1</code><br>
      </dd>
      <dt onclick="toggleDisplay('movlhps')"><b>movlhps</b> &boxh; move packed single-precision floating-point values low to high</dt>
      <dd id="movlhps" style="display: none;">
        <ul>
          <li>Moves two 32-bit single-precision floating-point values from the
              bottom 64 bits of the source XMM register to the top 64 bits of
              the destination XMM register</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movlhps &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movlhps xmm0, xmm1</code><br>
      </dd>
      <dt onclick="toggleDisplay('movss')"><b>movss</b> &boxh; move scalar single-precision floating-point value</dt>
      <dd id="movss" style="display: none;">
        <ul>
          <li>Moves a 32-bit single-precision floating-point value from a memory
              location into an XMM register</li>
          <li>Moves the single lowest 32-bit single-precision floating-point
              value from a source XMM register to a destination XMM register</li>
          <li>Moves scalar 32-bit single-precision floating-point value
              from a source XMM register into a memory location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movss &lt;xmm&gt;, &lt;xmm&#47;mem32&gt;</code><br>
        <code>movss &lt;xmm&#47;mem32&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movss xmm0, [rdi]</code><br>
        <code>movss xmm0, xmm1</code><br>
        <code>movss [rdi], xmm1</code><br>
      </dd>
      <dt onclick="toggleDisplay('movmskps')"><b>movmskps</b> &boxh; extract packed single-precision floating-point sign mask</dt>
      <dd id="movmskps" style="display: none;">
        <ul>
          <li>Extracts the sign bits from the four packed 32-bit single-precision
              floating-point values, formats them into a 4-bit mask, and stores
              it in the 4 low-order bits of the general-purpose register</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movmskps &lt;reg64&gt;, &lt;xmm&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movmskps rax, xmm1</code><br>
      </dd>
      <dt onclick="toggleDisplay('pextrw')"><b>pextrw</b> &boxh; extract word</dt>
      <dd id="pextrw" style="display: none;">
        <ul>
          <li>Extracts the 16-bit word from the source XMM register denoted by
              the 8-bit location mask into the bottom 16 bits of a
              general-purpose register</li>
          <li>Bits 16-63 are cleared in the destination register</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pextrw &lt;reg32&#47;reg64&gt;, &lt;xmm&gt;, imm8</code><br>
        <br>
        <em>Examples</em><br>
        <code>pextrw eax, xmm1, 2</code> &boxh; extract 3<sup>rd</sup> word of <code>XMM1</code> to <code>EAX</code><br>
      </dd>
      <dt onclick="toggleDisplay('pinsrw')"><b>pinsrw</b> &boxh; insert word</dt>
      <dd id="pinsrw" style="display: none;">
        <ul>
          <li>Extracts the bottom 16-bit word from the source general-purpose
              register and inserts it into the destination XMM register at the
              location specified by the 8-bit mask</li>
          <li>All other 16-bit words in the destination XMM register are not
              modified</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pinsrw &lt;xmm&gt;, &lt;reg32&gt;, imm8</code><br>
        <code>pinsrw &lt;xmm&gt;, &lt;mem16&gt;, imm8</code><br>
        <br>
        <em>Examples</em><br>
        <code>pinsrw xmm0, eax, 0</code> &boxh; insert <code>AX</code> into the 1<sup>st</sup> word of <code>XMM0</code><br>
      </dd>
    </dl>

    <h4>Non-Temporal Data Storage</h4>
    <p style="color: red; font-weight: bold;">WARNING: Non-Temporal data storage
      instructions are to be used with care! They can cause impossible bugs to
      find and/or serious performance degredation if used improperly!
    </p>
    <p>Non-Temporal data storage instructions are used as a hint to the CPU to
      minimize cache pollution during the write to memory.<br><br>
      The CPU will use a write-combining protocol to write the data directly to
      memory while bypassing the cache hierarchy.<br><br>
      A non-temporal data store also infers the program will completely replace
      the current content in memory, so it <b>does not</b> fetch the
      corresponding cache line from memory into the cache hierarchy.
    </p>

    <dl class="instruction">
      <dt onclick="toggleDisplay('movnti')"><b>movnti</b> &boxh; store doubleword&#47;quadword using non-temporal hint</dt>
      <dd id="movnti" style="display: none;">
        <ul>
          <li>Stores a 32-bit doubleword from a general-purpose regsiter into a
              memory location using non-temporal hint
          <li>Stores a 64-bit quadword from a general-purpose regsiter into a
              memory location using non-temporal hint
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>movnti &lt;mem32&gt;, &lt;reg32&gt;</code><br>
        <code>movnti &lt;mem64&gt;, &lt;reg64&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>movnti [rdi], eax</code><br>
        <code>movnti [rsi], rdx</code>
      </dd>
    </dl>

    <h3 id="sse2Shuffling">SSE2 Data Shuffling</h3>
    <p>
    A key concept about performing SIMD operations with SSE2 is the "multiple
    data" part. Data shuffling allows 16-bit words / 32-bit doublewords / 64-bit
    quadwords to be repackaged in a different way in an XMM register.
    </p>
    <dl class="instruction">
      <dt onclick="toggleDisplay('pshufd')"><b>pshufd</b> &boxh; shuffle packed doublewords</dt>
      <dd id="pshufd" style="display: none;">
        <ul>
          <li>Copies 32-bit doublewords from the source and inserts them into
              the destination XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
          <li>The immediate operand is an 8-bit mask that selects which 32-bit
              doublewords from the source are placed into the destination</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pshufd &lt;xmm&gt;, &lt;xmm&gt;, imm8</code><br>
        <code>pshufd &lt;xmm&gt;, &lt;mem128&gt;, imm8</code><br>
        <br>
        <em>Examples</em><br>
        <code>pshufd xmm0, xmm0, 0b</code> &boxh; broadcast the lowest 32-bit doubleword in <code>XMM0</code><br>
        <code>pshufd xmm0, [rdi], 10110110b</code><br>
      </dd>
      <dt onclick="toggleDisplay('pshuflw')"><b>pshuflw</b> &boxh; shuffle packed low words</dt>
      <dd id="pshuflw" style="display: none;">
        <ul>
          <li>Copies 16-bit words from the bottom 64 bits of the source and
              inserts them into the bottom four 16-bit words of the destination
              XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
          <li>The immediate operand is an 8-bit mask that selects which 16-bit
              words from the source are placed into the destination</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pshuflw &lt;xmm&gt;, &lt;xmm&gt;, imm8</code><br>
        <code>pshuflw &lt;xmm&gt;, &lt;mem128&gt;, imm8</code><br>
        <br>
        <em>Examples</em><br>
        <code>pshuflw xmm0, xmm0, 0b</code> &boxh; broadcast the lowest 16-bit word in <code>XMM0</code><br>
        <code>pshuflw xmm0, [rdi], 10110110b</code><br>
      </dd>
    </dl>
    </p>

    <h3 id="sse2Arithmetic">SSE2 Arithmetic Instructions</h3>
    <p>
    There are generally two types of SSE2 arithmetic instructions available:
    <ul>
      <li>Packed</li>
      <li>Scalar</li>
    </ul>
    Unfortunately, scalar instructions are limited only to single-precision and
    double-precision floating-point values. The only available instructions for
    integers are of the packed variety.
    </p>
    <dl class="instruction">
      <dt onclick="toggleDisplay('paddb')"><b>paddb</b> &boxh; add packed byte integers</dt>
      <dd id="paddb" style="display: none;">
        <ul>
          <li>Performs a SIMD add of the packed 8-bit byte integers from the source
              and the destination XMM register</li>
          <li>The source may either be another XMM register or a 64-bit memory
              location with a 128-bit value</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>paddb &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>paddb &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>paddb xmm0, xmm1</code><br>
        <code>paddb xmm0, [rdi]</code>
      </dd>
      <dt onclick="toggleDisplay('paddw')"><b>paddw</b> &boxh; add packed word integers</dt>
      <dd id="paddw" style="display: none;">
        <ul>
          <li>Performs a SIMD add of the packed 16-bit word integers from the source
              and the destination XMM register</li>
          <li>The source may either be another XMM register or a 64-bit memory
              location with a 128-bit value</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>paddw &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>paddw &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>paddw xmm0, xmm1</code><br>
        <code>paddw xmm0, [rdi]</code>
      </dd>
      <dt onclick="toggleDisplay('paddd')"><b>paddd</b> &boxh; add packed doubleword integers</dt>
      <dd id="paddd" style="display: none;">
        <ul>
          <li>Performs a SIMD add of the packed 32-bit doubleword integers from
              the source and the destination XMM register</li>
          <li>The source may either be another XMM register or a 64-bit memory
              location with a 128-bit value</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>paddd &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>paddd &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>paddd xmm0, xmm1</code><br>
        <code>paddd xmm0, [rdi]</code>
      </dd>
      <dt onclick="toggleDisplay('paddq')"><b>paddq</b> &boxh; add packed quadword integers</dt>
      <dd id="paddq" style="display: none;">
        <ul>
          <li>Performs a SIMD add of the packed 64-bit quadword integers from
              the source and the destination XMM register</li>
          <li>The source may either be another XMM register or a 64-bit memory
              location with a 128-bit value</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>paddq &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>paddq &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>paddq xmm0, xmm1</code><br>
        <code>paddq xmm0, [rdi]</code>
      </dd>
    </dl>
    </p>

    <h3 id="sse2Logic">SSE2 Logic Instructions</h3>
    <p>
    The SSE2 logic instructions allow the capability to perform the usual bitwise
    logic on XMM registers. Some logic instructions operate on the entire 128-bit
    register as a whole, while other logic instructions perform operations on
    packed values within the XMM register.
    </p>
    <dl class="instruction">
      <dt onclick="toggleDisplay('pand')"><b>pand</b> &boxh; logical AND</dt>
      <dd id="pand" style="display: none;">
        <ul>
          <li>Performs a 128-bit bitwise logical AND operation between the source
              and destination XMM register</li>
          <li>The source may either be another XMM register or a 64-bit memory
              location with a 128-bit value</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pand &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pand &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pand xmm0, xmm1</code><br>
        <code>pand xmm0, [rdi]</code><br>
      </dd>
      <dt onclick="toggleDisplay('pxor')"><b>pxor</b> &boxh; logical exclusive OR</dt>
      <dd id="pxor" style="display: none;">
        <ul>
          <li>Performs a 128-bit bitwise logical exclusive OR operation between
              the source and destination XMM register</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pxor &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pxor &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pxor xmm0, xmm1</code><br>
        <code>pxor xmm0, [rdi]</code><br>
      </dd>
      <dt onclick="toggleDisplay('pandn')"><b>pandn</b> &boxh; logical AND NOT</dt>
      <dd id="pandn" style="display: none;">
        <ul>
          <li>Performs a 128-bit bitwise logical NOT operation on the destination
              XMM register and then performs a bitwise logical AND with the source</li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pandn &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pandn &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pandn xmm0, xmm1</code><br>
        <code>pandn xmm0, [rdi]</code><br>
      </dd>
    </dl>

    <h3 id="sse2Compare">SSE2 Compare Instructions</h3>
    <p>
    SSE2 compare functionality is quite limited considering there are only a
    couple compare operations for integers.
    </p>
    <dl class="instruction">
      <dt onclick="toggleDisplay('pcmpeqb')"><b>pcmpeqb</b> &boxh; compare packed bytes for equal</dt>
      <dd id="pcmpeqb" style="display: none;">
        <ul>
          <li>Performs a SIMD compare for equality of the packed bytes between the
              destination XMM register and the source</li>
          <li>If a pair of bytes are equal, the corresponding byte in the
              destination XMM register is set to <code>0xff</code>; otherwise
              it is set to <code>0x00</code></li>
          <li>The source may either be another XMM register or a 128-bit memory
              location</li>
        </ul>
        <br>
        <em>Syntax</em><br>
        <code>pcmpeqb &lt;xmm&gt;, &lt;xmm&gt;</code><br>
        <code>pcmpeqb &lt;xmm&gt;, &lt;mem128&gt;</code><br>
        <br>
        <em>Examples</em><br>
        <code>pcmpeqb xmm0, xmm1</code><br>
        <code>pcmpeqb xmm0, [rdi]</code><br>
      </dd>
    </dl>
    </p>

    <br/>
    <div class="center">Copyright &copy; 2019 <a href="https://www.devopsbroker.org/">DevOpsBroker.org</a></div>
    <br/>
  </div>
</div>

</body>
</html>
